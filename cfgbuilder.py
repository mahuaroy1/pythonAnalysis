import ast
import argparse
from collections import defaultdict

class GlobalRegistry:
    """Tracks variables, lambdas, calls, and expressions across modules."""
    def __init__(self):
        self.registry = {}  # {module_name: {symbol_name: {context}}}

    def register_definition(self, module_name, symbol_name, context):
        if module_name not in self.registry:
            self.registry[module_name] = {}
        self.registry[module_name][symbol_name] = context

    def get_definition(self, module_name, symbol_name):
        return self.registry.get(module_name, {}).get(symbol_name, None)

class CFGNode:
    """Represents a basic block in the control flow graph."""
    def __init__(self, name, node_type,scope):
        self.name = name
        self.node_type = node_type  # Type of AST node (e.g., Assign, If, Try)
        self.statements = []
        self.scope = scope  # Scope the node belongs to
        self.successors = []
        self.gen = set()  # Definitions generated by the block
        self.kill = set()  # Definitions invalidated by the block
        self.in_set = set()  # Definitions available at the entry
        self.out_set = set()  # Definitions available at the exit
        self.use_map = defaultdict(set)  # Tracks uses for each definition

    def add_statement(self, statement):
        self.statements.append(statement)

    def add_successor(self, successor):
        self.successors.append(successor)

    def __repr__(self):
        #return f"CFGNode({self.name}, type={self.node_type}, successors={[s.name for s in self.successors]})"
        #return f"CFGNode({self.name}, type={self.node_type}, gen={self.gen}, kill={self.kill}, in_set={self.in_set}, out_set={self.out_set})"
        return (f"CFGNode({self.name}, type={self.node_type}, scope={self.scope}, "
                #f"gen={self.gen}, kill={self.kill}, in_set={self.in_set}, out_set={self.out_set}, "
                f"use_map={dict(self.use_map)})")

class ScopeManager:
    """Manages scope resolution."""
    def __init__(self):
        self.scopes = []  # Stack of active scopes
        self.global_vars = set()  # Track globally declared variables
        self.nonlocal_vars = set()  # Track nonlocally declared variables
        self.context_registry = {}  # Track variables and their context across scopes

    def enter_scope(self, scope_name):
        self.scopes.append({"name": scope_name, "local_vars": set()})

    def exit_scope(self):
        self.scopes.pop()

    def current_scope(self):
        return self.scopes[-1]["name"] if self.scopes else "global"

    def add_local_var(self, var_name):
        if self.scopes:
            current_scope = self.scopes[-1]["name"]
            self.scopes[-1]["local_vars"].add(var_name)
            self.context_registry[var_name] = {"scope": current_scope, "usages": set()}

    def add_global_var(self, var_name):
        self.global_vars.add(var_name)
        self.context_registry[var_name] = {"scope": "global", "usages": set()}

    def add_nonlocal_var(self, var_name):
        self.nonlocal_vars.add(var_name)
        self.context_registry[var_name] = {"scope": "nonlocal", "usages": set()}

    def resolve_scope(self, var_name):
        # Check if the variable is global
        if var_name in self.global_vars:
            return "global"
        # Check if the variable is nonlocal
        if var_name in self.nonlocal_vars:
            return "nonlocal"
        # Check if the variable is local in the current scope
        for scope in reversed(self.scopes):
            if var_name in scope["local_vars"]:
                return scope["name"]

        # Default to global scope
        return "global"

    def register_usage(self, var_name, usage_scope):
        if var_name in self.context_registry:
            self.context_registry[var_name]["usages"].add(usage_scope)

class CFGBuilder(ast.NodeVisitor):
    """Builds a control flow graph from Python source code."""
    def __init__(self):
        self.nodes = {}
        self.current_node = None
        self.counter = 0
        self.scope_manager = ScopeManager()

    def _create_node(self, name, node_type):
        node = CFGNode(name, node_type,self.scope_manager.current_scope())
        self.nodes[name] = node
        return node

    def visit_Module(self, node):
        self.scope_manager.enter_scope("global")  # Enter global scope
        start_node = self._create_node("start", "Module")
        self.current_node = start_node
        for stmt in node.body:
            self.visit(stmt)
        self.scope_manager.exit_scope()  # Exit global scope

    def visit_Import(self, node):
        import_node = self._create_node(f"import_{self.counter}", "Import")
        self.counter += 1
        # Add imported module names to the gen set
        for alias in node.names:
            import_node.gen.add(alias.name)
            # Register the imported symbol in the global registry
            self.global_registry.register_definition(self.scope_manager.current_scope(), alias.name, {
                "type": "module",
                "imported_as": alias.asname or alias.name
            })
        self.current_node.add_successor(import_node)
        self.current_node = import_node

    def visit_ImportFrom(self, node):
        importfrom_node = self._create_node(f"importfrom_{self.counter}", "ImportFrom")
        self.counter += 1
        module_name = node.module or "global"
        # Add imported names to the gen set with module context
        for alias in node.names:
            name = f"{node.module}.{alias.name}" if node.module else alias.name
            importfrom_node.gen.add(name)
            # Register the imported symbol in the global registry
            self.global_registry.register_definition(self.scope_manager.current_scope(), alias.name, {
                "type": "module",
                "imported_from": module_name,
                "imported_as": alias.asname or alias.name
            })
        self.current_node.add_successor(importfrom_node)
        self.current_node = importfrom_node

    def visit_ClassDef(self, node):
        self.scope_manager.enter_scope(node.name)  # Enter class scope
        class_node = self._create_node(node.name, "ClassDef")
        self.current_node.add_successor(class_node)
        self.current_node = class_node
        for stmt in node.body:
            self.visit(stmt)
        self.scope_manager.exit_scope()  # Exit class scope

    def visit_FunctionDef(self, node):
        self.scope_manager.enter_scope(node.name)  # Enter function scope
        func_node = self._create_node(node.name, "FunctionDef")
        self.current_node.add_successor(func_node)
        self.current_node = func_node
        # Add arguments to the gen set
        for arg in node.args.args:
            self.scope_manager.add_local_var(arg.arg)
            func_node.gen.add(arg.arg)
        for stmt in node.body:
            self.visit(stmt)
        # Handle decorators
        for decorator in node.decorator_list:
            self.visit(decorator)
        self.scope_manager.exit_scope()  # Exit function scope

    def visit_AsyncFunctionDef(self, node):
        self.scope_manager.enter_scope(node.name)  # Enter function scope
        async_func_node = self._create_node(node.name, "AsyncFunctionDef")
        self.current_node.add_successor(async_func_node)
        self.current_node = async_func_node
        # Add arguments to the gen set
        for arg in node.args.args:
            self.scope_manager.add_local_var(arg.arg)
            async_func_node.gen.add(arg.arg)
        for stmt in node.body:
            self.visit(stmt)
        self.scope_manager.exit_scope()  # Exit function scope

    def visit_Global(self, node):
        for name in node.names:
            self.scope_manager.add_global_var(name)

    def visit_Nonlocal(self, node):
        for name in node.names:
            self.scope_manager.add_nonlocal_var(name)

    def visit_Call(self, node):
        call_node = self._create_node(f"call_{self.counter}", "Call")
        self.counter += 1

        # Track variables used as arguments
        for arg in node.args:
            if isinstance(arg, ast.Name):
                arg_scope = self.scope_manager.resolve_scope(arg.id)
                # Check if the argument is defined in another module
                global_definition = self.global_registry.get_definition(arg_scope, arg.id)
                if global_definition:
                    call_node.gen.add(arg.id)
                    call_node.use_map[global_definition["type"]].add(arg.id)
                else:
                    call_node.gen.add(arg.id)
                    call_node.use_map[arg_scope].add(arg.id)

            elif isinstance(arg, ast.Lambda):
                # Handle lambda passed as an argument
                lambda_id = self._handle_lambda_as_argument(arg)
                call_node.gen.add(lambda_id)

        # Track the function being called (if it's an attribute)
        # Track the callable itself
        # Resolve the callable source (e.g., function, method, or dynamic callable)
        if isinstance(node.func, ast.Name):
            func_scope = self.scope_manager.resolve_scope(node.func.id)
            global_definition = self.global_registry.get_definition(func_scope, node.func.id)
            if global_definition:
                call_node.gen.add(node.func.id)
                call_node.use_map[global_definition["type"]].add(node.func.id)
            else:
                call_node.gen.add(node.func.id)
                call_node.use_map[func_scope].add(node.func.id)

        elif isinstance(node.func, ast.Attribute):
            # Handle attributes (e.g. obj.method)
            self._process_attribute(node.func, call_node)  # Callable via chained attributes
        elif isinstance(node.func, ast.Call):
            # Handle nested calls dynamically
            self.visit(node.func)
        elif isinstance(node.func, ast.Lambda):
            # Handle inline lambda calls
            self.visit_Lambda(node.func)

        self.current_node.add_successor(call_node)
        self.current_node = call_node

    def _handle_lambda_as_argument(self, lambda_node):
        """Handle lambdas passed as arguments."""
        # Visit the lambda to ensure it is processed
        self.visit_Lambda(lambda_node)

        # Return the unique ID of the lambda
        return f"lambda_{self.counter - 1}"

    def visit_Lambda(self, node):
        lambda_id = f"lambda_{self.counter}"
        lambda_node = self._create_node(lambda_id, "Lambda")
        self.counter += 1

        # Enter a new scope for the lambda
        self.scope_manager.enter_scope(f"lambda_{self.counter}")

        # Add lambda arguments to gen and register as local variables
        for arg in node.args.args:
            lambda_node.gen.add(arg.arg)
            self.scope_manager.add_local_var(arg.arg)

        # Process the body and propagate free variables
        free_vars = self._extract_free_vars(node)
        for var in free_vars:
            var_scope = self.scope_manager.resolve_scope(var)
            if var_scope != self.scope_manager.current_scope():
                self.global_registry.register_definition(var_scope, var, {"type": "variable", "used_in": lambda_id})

        # Register the lambda globally
        self.global_registry.register_definition(self.scope_manager.current_scope(), lambda_id, {
            "type": "lambda",
            "free_vars": free_vars
        })

        # Visit the body of the lambda expression
        if isinstance(node.body, ast.Name):
            # Handle variable usage in the lambda body
            var_scope = self.scope_manager.resolve_scope(node.body.id)
            self.scope_manager.register_usage(node.body.id, lambda_id)
            lambda_node.gen.add(node.body.id)
            lambda_node.use_map[var_scope].add(node.body.id)
        elif isinstance(node.body, ast.BinOp):
            # Handle binary operations in the lambda body
            self.visit_BinOp(node.body)
        elif isinstance(node.body, ast.Call):
            # Handle function or method calls in the lambda body
            self.visit_Call(node.body)
        elif isinstance(node.body, ast.Attribute):
            # Handle attributes in the lambda body
            self.visit_Attribute(node.body)
        elif isinstance(node.body, ast.Lambda):
            # Handle nested lambdas
            self.visit_Lambda(node.body)
        else:
            self.visit(node.body)

        # Link the lambda node to the current CFG
        self.current_node.add_successor(lambda_node)

        # Register the lambda definition in the global lambda registry
        '''
        if not hasattr(self, "lambda_registry"):
            self.lambda_registry = {}  # Initialize registry
        self.lambda_registry[lambda_id] = {
            "scope": self.scope_manager.current_scope(),
            "node": lambda_node,
            "free_vars": self._extract_free_vars(node)
        }
        '''
        # Register the lambda definition in the global context
        self.scope_manager.context_registry[lambda_id] = {
            "scope": self.scope_manager.current_scope(),
            "free_vars": self._extract_free_vars(node)
        }
        # Exit the lambda's scope
        self.scope_manager.exit_scope()
        self.current_node.add_successor(lambda_node)
        self.current_node = lambda_node

    def _extract_free_vars(self, node):
        """Extract free variables used in the lambda body."""
        free_vars = set()

        def find_free_vars(subnode):
            if isinstance(subnode, ast.Name):
                if isinstance(subnode.ctx, ast.Load):  # Only consider variables being read
                    var_scope = self.scope_manager.resolve_scope(subnode.id)
                    if var_scope != self.scope_manager.current_scope():
                        free_vars.add(subnode.id)
            elif isinstance(subnode, ast.BinOp):
                find_free_vars(subnode.left)
                find_free_vars(subnode.right)
            elif isinstance(subnode, ast.Call):
                for arg in subnode.args:
                    find_free_vars(arg)
            elif isinstance(subnode, ast.Attribute):
                find_free_vars(subnode.value)

        find_free_vars(node.body)
        return free_vars

    def visit_Attribute(self, node):
        attr_node = self._create_node(f"attribute_{self.counter}", "Attribute")
        self.counter += 1
        # Recursively handle deeply nested attributes
        self._process_attribute(node, attr_node)
        self.current_node.add_successor(attr_node)
        self.current_node = attr_node

    def _process_attribute(self, node, attr_node):
        # Resolve the base object (value) of the attribute
        if isinstance(node.value, ast.Name):
            base_scope = self.scope_manager.resolve_scope(node.value.id)
            attr_node.gen.add(node.value.id)  # Add base object to gen
            attr_node.use_map[base_scope].add(node.value.id)

        # Handle chained attributes recursively (e.g., obj.attr.subattr)
        elif isinstance(node.value, ast.Attribute):
            self._process_attribute(node.value, attr_node)  # Recurse for ch

        # Add the attribute itself for tracking (as it might be a method or property)
        if hasattr(node, "attr") and isinstance(node.attr, str):
            attr_node.gen.add(node.attr)  # Track the attribute being accessed

    def visit_If(self, node):
        condition_node = self._create_node(f"if_condition_{self.counter}", "If")
        self.counter += 1
        self.current_node.add_successor(condition_node)
        self.current_node = condition_node
        # Visit the then branch
        then_node = self._create_node(f"if_then_{self.counter}", "IfThen")
        self.counter += 1
        self.current_node.add_successor(then_node)
        self.current_node = then_node
        for stmt in node.body:
            self.visit(stmt)
        # Visit the else branch (if exists)
        if node.orelse:
            else_node = self._create_node(f"if_else_{self.counter}", "IfElse")
            self.counter += 1
            self.current_node.add_successor(else_node)
            self.current_node = else_node
            for stmt in node.orelse:
                self.visit(stmt)

    def visit_For(self, node):
        for_node = self._create_node(f"for_loop_{self.counter}", "For")
        self.counter += 1
        self.current_node.add_successor(for_node)
        self.current_node = for_node
        for stmt in node.body:
            self.visit(stmt)

    def visit_While(self, node):
        while_node = self._create_node(f"while_loop_{self.counter}", "While")
        self.counter += 1
        self.current_node.add_successor(while_node)
        self.current_node = while_node
        for stmt in node.body:
            self.visit(stmt)

    def visit_Try(self, node):
        try_node = self._create_node(f"try_block_{self.counter}", "Try")
        self.counter += 1
        self.current_node.add_successor(try_node)
        self.current_node = try_node
        # Visit the try block
        for stmt in node.body:
            self.visit(stmt)
        # Visit except blocks
        for handler in node.handlers:
            self.visit(handler)
        # Visit the finally block
        if node.finalbody:
            finally_node = self._create_node(f"finally_block_{self.counter}", "Finally")
            self.counter += 1
            self.current_node.add_successor(finally_node)
            for stmt in node.finalbody:
                self.visit(stmt)

    def visit_Raise(self, node):
        raise_node = self._create_node(f"raise_{self.counter}", "Raise")
        self.counter += 1
        self.current_node.add_successor(raise_node)

    def visit_ExceptHandler(self, node):
        except_node = self._create_node(f"except_{self.counter}", "ExceptHandler")
        self.counter += 1
        if node.name:  # Variable defined in `except Exception as name:`
            except_node.gen.add(node.name)
        self.current_node.add_successor(except_node)
        self.current_node = except_node
        for stmt in node.body:
            self.visit(stmt)

    def visit_Global(self, node):
        global_node = self._create_node(f"global_{self.counter}", "Global")
        self.counter += 1
        # Global variables are not new definitions, so they are not added to `gen`.
        self.current_node.add_successor(global_node)
        self.current_node = global_node

    def visit_Nonlocal(self, node):
        nonlocal_node = self._create_node(f"nonlocal_{self.counter}", "Nonlocal")
        self.counter += 1
        # Nonlocal variables are not new definitions, so they are not added to `gen`.
        self.current_node.add_successor(nonlocal_node)
        self.current_node = nonlocal_node

    def visit_With(self, node):
        with_node = self._create_node(f"with_{self.counter}", "With")
        self.counter += 1
        self.current_node.add_successor(with_node)
        self.current_node = with_node
        for stmt in node.body:
            self.visit(stmt)

    def visit_Yield(self, node):
        yield_node = self._create_node(f"yield_{self.counter}", "Yield")
        self.counter += 1
        self.current_node.add_successor(yield_node)

    def visit_ListComp(self, node):
        list_comp_node = self._create_node(f"list_comp_{self.counter}", "ListComp")
        self.counter += 1
        self.current_node.add_successor(list_comp_node)

    def visit_DictComp(self, node):
        dict_comp_node = self._create_node(f"dict_comp_{self.counter}", "DictComp")
        self.counter += 1
        self.current_node.add_successor(dict_comp_node)

    def visit_GeneratorExp(self, node):
        generator_exp_node = self._create_node(f"generator_exp_{self.counter}", "GeneratorExp")
        self.counter += 1
        self.current_node.add_successor(generator_exp_node)

    def visit_Assign(self, node):
        assign_node = self._create_node(f"assign_{self.counter}", "Assign")
        self.counter += 1
        # Add definitions to the Gen set
        for target in node.targets:
            if isinstance(target, ast.Name):
                self.scope_manager.add_local_var(target.id)
                assign_node.gen.add(target.id) # Treat as definition
                # Invalidate previous definitions in Kill set
                for cfg_node in self.nodes.values():
                    if target.id in cfg_node.gen:
                        assign_node.kill.add(target.id)

        self.current_node.add_successor(assign_node)
        self.current_node = assign_node

    def visit_AnnAssign(self, node):
        annassign_node = self._create_node(f"annassign_{self.counter}", "AnnAssign")
        self.counter += 1
        if isinstance(node.target, ast.Name):
            self.scope_manager.add_local_var(node.target.id)
            annassign_node.gen.add(node.target.id)
            for cfg_node in self.nodes.values():
                if node.target.id in cfg_node.gen:
                    annassign_node.kill.add(node.target.id)
        self.current_node.add_successor(annassign_node)
        self.current_node = annassign_node

    def visit_AugAssign(self, node):
        augassign_node = self._create_node(f"augassign_{self.counter}", "AugAssign")
        self.counter += 1
        if isinstance(node.target, ast.Name):
            self.scope_manager.add_local_var(node.target.id)
            augassign_node.gen.add(node.target.id)  # Treat as use (read)
            augassign_node.kill.add(node.target.id)  # Treat as redefinition (write)
        self.current_node.add_successor(augassign_node)
        self.current_node = augassign_node

    def visit_Subscript(self, node):
        subscript_node = self._create_node(f"subscript_{self.counter}", "Subscript")
        self.counter += 1
        if isinstance(node.value, ast.Name):
            subscript_node.gen.add(node.value.id)  # Treat as a use of the variable
        self.current_node.add_successor(subscript_node)

    def visit_Expr(self, node):
        expr_node = self._create_node(f"expr_{self.counter}", "Expr")
        self.counter += 1

        # Analyze the expression's value (e.g., a function call, variable, or attribute)
        if isinstance(node.value, ast.Name):
            # Handle variable references
            var_scope = self.scope_manager.resolve_scope(node.value.id)
            # Check if the variable is defined in another module
            global_definition = self.global_registry.get_definition(var_scope, node.value.id)
            if global_definition:
                expr_node.gen.add(node.value.id)
                expr_node.use_map[global_definition["type"]].add(node.value.id)
            else:
                expr_node.gen.add(node.value.id)
                expr_node.use_map[var_scope].add(node.value.id)

        elif isinstance(node.value, ast.Attribute):
            # Handle attributes (e.g., obj.method)
            self.visit_Attribute(node.value)

        elif isinstance(node.value, ast.Call):
            # Handle function or method calls within expressions
            self.visit_Call(node.value)
        elif isinstance(node.value, ast.BinOp):
            # Handle binary operations within the expression
            self.visit_BinOp(node.value)

        elif isinstance(node.value, ast.UnaryOp):
            # Handle unary operations within the expression
            self.visit_UnaryOp(node.value)

        # Link the expression node to the current CFG
        self.current_node.add_successor(expr_node)
        self.current_node = expr_node

    def visit_BinOp(self, node):
        binop_node = self._create_node(f"binop_{self.counter}", "BinOp")
        self.counter += 1
        # Add variables used in the binary operation to the `gen` set.
        if isinstance(node.left, ast.Name):
            binop_node.gen.add(node.left.id)
        if isinstance(node.right, ast.Name):
            binop_node.gen.add(node.right.id)
        self.current_node.add_successor(binop_node)

    def visit_UnaryOp(self, node):
        unaryop_node = self._create_node(f"unaryop_{self.counter}", "UnaryOp")
        self.counter += 1
        # Add the variable used in the unary operation to the `gen` set.
        if isinstance(node.operand, ast.Name):
            unaryop_node.gen.add(node.operand.id)
        self.current_node.add_successor(unaryop_node)

    def visit_Name(self, node):
        name_node = self._create_node(f"name_{self.counter}", "Name")
        self.counter += 1
        # Track variable usage with scope resolution
        if isinstance(node.ctx, ast.Load):  # Load context implies use
            var_scope = self.scope_manager.resolve_scope(node.id)
            # Check if the variable is defined in another module
            global_definition = self.global_registry.get_definition(var_scope, node.id)
            if global_definition:
                self.current_node.use_map[global_definition["type"]].add(node.id)
            else:
                self.current_node.use_map[var_scope].add(node.id)
            ''''
            self.scope_manager.register_usage(node.id, self.scope_manager.current_scope())
            self.current_node.use_map[var_scope].add(node.id)
            '''
        self.current_node.add_successor(name_node)

    def visit_Return(self, node):
        return_node = self._create_node(f"return_{self.counter}", "Return")
        self.counter += 1
        self.current_node.add_successor(return_node)

    def dataflow_analysis(self):
        """Performs dataflow analysis to compute reaching definitions."""
        # Initialize In and Out sets
        for node in self.nodes.values():
            node.in_set = set()
            node.out_set = node.gen.copy()

        # Iterate until fixpoint
        changed = True
        while changed:
            changed = False
            for node in self.nodes.values():
                # Compute In set as union of Out sets of predecessors
                in_set_new = set()
                for pred in self.nodes.values():
                    if node in pred.successors:
                        in_set_new |= pred.out_set
                # Compute Out set: Gen ∪ (In - Kill)
                out_set_new = node.gen | (in_set_new - node.kill)
                if node.in_set != in_set_new or node.out_set != out_set_new:
                    node.in_set = in_set_new
                    node.out_set = out_set_new
                    changed = True


class MultiModuleCFGBuilder(CFGBuilder):
    def __init__(self, global_registry):
        super().__init__()
        self.global_registry = global_registry  # Reference to the global registry

